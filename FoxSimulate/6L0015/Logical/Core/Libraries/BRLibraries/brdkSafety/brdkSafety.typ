
TYPE
	brdkSafety_states_typ : 
		( (*the state of the function block*)
		BRDKSAFETY_DISABLED := 0, (*function block is disabled*)
		BRDKSAFETY_IDLE := 10, (*function block is idle*)
		BRDKSAFETY_READ_UDID_LOW_SLX := 20, (*function block is reading the low UDID of the SLX*)
		BRDKSAFETY_READ_UDID_HIGH_SLX := 30, (*function block is reading the high UDID of the SLX*)
		BRDKSAFETY_READ_UDID_LOW_SL := 40, (*function block is reading the low UDID of the SL*)
		BRDKSAFETY_READ_UDID_HIGH_SL := 50, (*function block is reading the high UDID of the SL*)
		BRDKSAFETY_CMD_MONITOR_STATUS := 100, (*function block is monitoring the status*)
		BRDKSAFETY_CMD_READ_STATUS := 101, (*function block is reading the status*)
		BRDKSAFETY_CMD_FIRMWARE_ACK := 102, (*function block is acknowledging the new firmware*)
		BRDKSAFETY_CMD_MODULE_EXCH_1 := 103, (*function block is exchanging 1 module*)
		BRDKSAFETY_CMD_MODULE_EXCH_2 := 104, (*function block is exchanging 2 modules*)
		BRDKSAFETY_CMD_MODULE_EXCH_3 := 105, (*function block is exchanging 3 modules*)
		BRDKSAFETY_CMD_MODULE_EXCH_4 := 106, (*function block is exchanging 4 modules*)
		BRDKSAFETY_CMD_MODULE_EXCH_N := 107, (*function block is exchanging N modules*)
		BRDKSAFETY_CMD_SAFEKEY_EXCH := 108, (*function block is exchanging the SafeKEY*)
		BRDKSAFETY_CMD_SAFEKEY_FORMAT := 109, (*function block is formatting the SafeKEY*)
		BRDKSAFETY_CMD_SCAN := 110, (*function block is scanning*)
		BRDKSAFETY_CMD_SET_PASSWORD := 111, (*function block is setting a new password*)
		BRDKSAFETY_CMD_TEST := 112, (*function block is testing*)
		BRDKSAFETY_CMD_CLEAR_DATA := 113, (*function block is clearing the data*)
		BRDKSAFETY_CMD_RESET_SAFELOGIC := 114, (*function block is resetting the SafeLOGIC*)
		BRDKSAFETY_CMD_SETUP_ENABLE := 115, (*function block is enabling the setup mode*)
		BRDKSAFETY_CMD_SETUP_DISABLE := 116, (*function block is disabling the setup mode*)
		BRDKSAFETY_CMD_DOWNLOAD_APP := 200, (*function block is downloading the application*)
		BRDKSAFETY_CMD_DOWNLOAD_DATA := 300, (*function block is downloading the data*)
		BRDKSAFETY_CMD_READ_DATA := 400, (*function block is reading the data*)
		BRDKSAFETY_DONE := 1000, (*function block is done*)
		BRDKSAFETY_ERROR := 2000 (*function block has an error*)
		);
	brdkSafety_module_flag_typ : 
		( (*which type of data to transfer to the SafeLogic*)
		BRDKSAFETY_FLAG_NONE := 0, (*machine options*)
		BRDKSAFETY_FLAG_OPTIONAL := 10, (*machine options*)
		BRDKSAFETY_FLAG_STARTUP := 20, (*machine options*)
		BRDKSAFETY_FLAG_NOTPRESENT := 30 (*machine options*)
		);
	brdkSafety_type_typ : 
		( (*which type of data to transfer to the SafeLogic*)
		BRDKSAFETY_TYPE_OPTIONS := 0, (*machine options*)
		BRDKSAFETY_TYPE_EXTOPTIONS := 10, (*extended machine options*)
		BRDKSAFETY_TYPE_TABLEOBJECTS := 20 (*table objects*)
		);
	brdkSafety_option_setup_typ : 
		( (*which type of data to transfer to the SafeLogic*)
		BRDKSAFETY_SET_OPTIONS_ONLY := 0, (*machine options is only used*)
		BRDKSAFETY_SET_FLAGS_ONLY := 10, (*module flags is only used*)
		BRDKSAFETY_SET_OPTIONS_AND_FLAGS := 20 (*machine options and module flags is used*)
		);
	brdkSafety_option_status_typ : 	STRUCT  (*machine options*)
		moduleFlags : ARRAY[0..BRDKSAFETY_MAX_MODULES]OF brdkSafety_module_flag_typ; (*module flags to be downloaded. optional. Index 1 = SafeModule 1, Index 2 = SafeModule 2, etc.*)
		optionsBool : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*machine options. BitData[0].0 equals "ExternalMachineOption000" and BitData[0].1 equals "ExternalMachineOption001"*)
	END_STRUCT;
	brdkSafety_ext_option_status_typ : 	STRUCT  (*extended machine options*)
		optionsInt : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF INT; (*machine options INT*)
		optionsUint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF UINT; (*machine options UINT*)
		optionsDint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF DINT; (*machine options DINT*)
		optionsUdint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF UDINT; (*machine options UDINT*)
	END_STRUCT;
	brdkSafety_ext_option_setup_typ : 	STRUCT  (*setup for extended machine options*)
		numberOfInt : UINT; (*number of used external INT machine options*)
		numberOfUint : UINT; (*number of used external UINT machine options*)
		numberOfDint : UINT; (*number of used external DINT machine options*)
		numberOfUdint : UINT; (*number of used external UDINT machine options*)
	END_STRUCT;
	brdkSafety_ext_option_ack_typ : 	STRUCT  (*acknowledge options*)
		acknIntOptions : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*acknowledge INT*)
		acknUintOptions : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*acknowledge UINT*)
		acknDintOptions : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*acknowledge DINT*)
		acknUdintOptions : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*acknowledge UDINT*)
	END_STRUCT;
	brdkSafety_ext_option_par_typ : 	STRUCT  (*extended machine options*)
		optionsInt : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF INT; (*machine options INT to be downloaded*)
		optionsUint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF UINT; (*machine options UINT to be downloaded*)
		optionsDint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF DINT; (*machine options DINT to be downloaded*)
		optionsUdint : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF UDINT; (*machine options UDINT to be downloaded*)
		acknOptions : brdkSafety_ext_option_ack_typ; (*acknowledge options*)
	END_STRUCT;
	brdkSafety_option_par_typ : 	STRUCT  (*machine options*)
		moduleFlags : ARRAY[0..BRDKSAFETY_MAX_MODULES]OF brdkSafety_module_flag_typ; (*module flags to be downloaded. optional. Index 1 = SafeModule 1, Index 2 = SafeModule 2, etc.*)
		optionsBool : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*machine options to be downloaded*)
		acknBoolOptions : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF BOOL; (*acknowledge machine options*)
	END_STRUCT;
	brdkSafety_remote_cmd_typ : 	STRUCT  (*remote control cmd*)
		moduleExchange1 : BOOL := FALSE; (*confirms the exchange of 1 module*)
		moduleExchange2 : BOOL := FALSE; (*confirms the exchange of 2 modules*)
		moduleExchange3 : BOOL := FALSE; (*confirms the exchange of 3 modules*)
		moduleExchange4 : BOOL := FALSE; (*confirms the exchange of 4 modules*)
		moduleExchangeN : BOOL := FALSE; (*confirms the exchange of more than 4 modules*)
		monitorStatus : BOOL := FALSE; (*command monitor status*)
		readStatus : BOOL := FALSE; (*command read status*)
		firmwareAcknowledge : BOOL := FALSE; (*confirms a new firmware for one or more modules*)
		safeKeyExchange : BOOL := FALSE; (*confirms a SafeKEY exchange*)
		clearData : BOOL := FALSE; (*clears subsequently loaded data*)
		resetSafeLogic : BOOL := FALSE; (*resets the safety controller*)
		safeKeyFormat : BOOL := FALSE; (*formats the SafeKEY*)
		reset : BOOL := FALSE; (*command reset function block from error*)
		scan : BOOL := FALSE; (*triggers a module scan*)
		setPassword : BOOL := FALSE; (*changing/setting a new SafeLOGIC password*)
		test : BOOL := FALSE; (*triggers a LED test of the SafeLOGIC (can't be used with SLX)*)
		setupModeEnable : BOOL := FALSE; (*enable setup mode*)
		setupModeDisable : BOOL := FALSE; (*disable setup mode*)
	END_STRUCT;
	brdkSafety_remote_setup_typ : 	STRUCT  (*remote control setup*)
		safeLogicID : UINT; (*safeLogic ID*)
		safeKEYpassword : STRING[16]; (*safeKEY password*)
		safeKEYnewPassword : STRING[16]; (*safeKEY new password*)
	END_STRUCT;
	brdkSafety_remote_status_typ : 	STRUCT  (*remote control status*)
		firstRead : BOOL := FALSE; (*flag for checking for first read status*)
		cmdRequest : brdkSafety_remote_request_typ; (*cmd request*)
		safeOSState : STRING[100]; (*status of the safety application*)
		modulesState : STRING[100]; (*status of the safe modules*)
		systemState : STRING[100]; (*status of the system*)
		operationMode : STRING[100]; (*status of the operation mode*)
		status : STRING[100]; (*general status of the function block*)
		lastErrorID : UINT := 0; (*last error ID (check help for more information)*)
	END_STRUCT;
	brdkSafety_remote_internal_typ : 	STRUCT  (*remote control internal*)
		state : brdkSafety_states_typ := (0); (*function block state*)
		TON_MonitorStatus : TON; (*timer for monitor status*)
		remoteControl : safeRemoteControl_V2; (*function block safeRemoteControl*)
		remoteControlCmdType : RemoteControlCmdTypeV1; (*command structure for remote control*)
		remoteControlStatusType : RemoteControlStatusTypeV2; (*status structure of the safety controller*)
	END_STRUCT;
	brdkSafety_remote_request_typ : 	STRUCT  (*cmd request*)
		downloadApplication : BOOL := FALSE; (*application is needed*)
		setPassword : BOOL := FALSE; (*password is needed*)
		setupModeEnabled : BOOL; (*setup mode is enabled*)
		safeKeyExchange : BOOL := FALSE; (*SafeKEY exchange request*)
		firmwareAcknowledge : {REDUND_UNREPLICABLE} BOOL := FALSE; (*new firmware for one or more modules request*)
		moduleExchange1 : BOOL := FALSE; (*exchange of 1 module request*)
		moduleExchange2 : BOOL := FALSE; (*exchange of 2 modules request*)
		moduleExchange3 : BOOL := FALSE; (*exchange of 3 modules request*)
		moduleExchange4 : BOOL := FALSE; (*exchange of 4 modules request*)
		moduleExchangeN : BOOL := FALSE; (*exchange of more than 4 modules request*)
	END_STRUCT;
	brdkSafety_app_cmd_typ : 	STRUCT  (*download application commands*)
		reset : BOOL := FALSE; (*command reset*)
		download : BOOL := FALSE; (*downloads the application to the SafeLOGIC*)
		acknowledge : BOOL := FALSE; (*command acknowledge*)
		cancelDownload : BOOL := FALSE; (*command cancel download. Note this will bring the SafeLogic to FailSafe and a new download will be required*)
	END_STRUCT;
	brdkSafety_app_setup_typ : 	STRUCT  (*download application setup*)
		filename : STRING[80]; (*filename of the safety application*)
		devicename : STRING[80]; (*device name of an existing file device where the safety application is stored*)
		downloadFromFile : BOOL := FALSE; (*TRUE=download from file, FALSE=download from gray CPU stored as B&R module*)
		SLnode : USINT; (*SL node (only needed if SLXused=FALSE)*)
		SLinterface : STRING[16]; (*SL interface (only needed if SLXused=FALSE)*)
		SLXstation : STRING[16]; (*SLX station (only needed if SLXused=TRUE)*)
		SLXused : BOOL; (*if SLX is used set TRUE, if SL is used set FALSE*)
		safeKEYpassword : STRING[9]; (*safeKEY password*)
		safeLogicID : UINT; (*safeLogic ID*)
	END_STRUCT;
	brdkSafety_app_status_typ : 	STRUCT  (*download application status*)
		applicationCRC : UDINT := 0; (*CRC of the application transferred to the safety controller*)
		lastErrorID : UINT := 0; (*last error ID (check help for more information)*)
		status : STRING[100]; (*general status of the function block*)
	END_STRUCT;
	brdkSafety_app_internal_typ : 	STRUCT  (*download application internal*)
		state : brdkSafety_states_typ := (0); (*function block state*)
		downloadApplication : safeDownloadApplication_V2; (*function block for download safety application to the safety controller*)
		downloadCmdApplicationType : DownloadCmdApplicationTypeV1; (*command structure for downloading the application*)
		EplSDORead_0 : EplSDORead; (*function block to read UDIDs from SL device*)
		AsIOAccRead_0 : AsIOAccRead; (*function block to read UDIDs from SLX device*)
		UDID_High : UINT := 0; (*UDID_high for SafelOGIC*)
		UDID_Low : UDINT := 0; (*UDID_low for SafeLOGIC*)
	END_STRUCT;
	brdkSafety_data_cmd_typ : 	STRUCT  (*download data cmds*)
		download : BOOL := FALSE; (*command download*)
		cancelDownload : BOOL := FALSE; (*command cancel download*)
		read : BOOL := FALSE; (*command read*)
		acknowledge : BOOL := FALSE; (*command acknowledge*)
		reset : BOOL := FALSE; (*command reset*)
	END_STRUCT;
	brdkSafety_data_setup_typ : 	STRUCT  (*download data setup*)
		filenameOfTableObject : ARRAY[0..BRDKSAFETY_MAX_TABLES]OF STRING[80]; (*filename of the table objects*)
		devicenameForTableObjects : STRING[80]; (*device name of an existing file device where the table objects is stored*)
		numberOfTableObjects : USINT; (*number of table objects*)
		machineOptions : brdkSafety_option_setup_typ; (*setup for extended machine options*)
		extendedMachineOptions : brdkSafety_ext_option_setup_typ; (*setup for extended machine options*)
		SLnode : USINT; (*SL node (only needed if SLXused=FALSE)*)
		SLinterface : STRING[16]; (*SL interface (only needed if SLXused=FALSE)*)
		SLXstation : STRING[16]; (*SLX station (only needed if SLXused=TRUE)*)
		SLXused : BOOL; (*if SLX is used set TRUE, if SL is used set FALSE*)
		safeKEYpassword : STRING[9]; (*safeKEY password*)
		safeLogicID : UINT; (*safeLogic ID*)
	END_STRUCT;
	brdkSafety_data_par_typ : 	STRUCT  (*download data parameters*)
		machineOptions : brdkSafety_option_par_typ; (*machine options*)
		extendedMachineOptions : brdkSafety_ext_option_par_typ; (*extended machine options*)
		type : brdkSafety_type_typ; (*type of download data*)
	END_STRUCT;
	brdkSafety_data_status_typ : 	STRUCT  (*download data status*)
		lastTimestamp : UDINT := 0; (*last timestamp that was acknowledged*)
		machineOptions : brdkSafety_option_status_typ; (*machine options*)
		extendedMachineOptions : brdkSafety_ext_option_status_typ; (*extended machine options*)
		status : STRING[100]; (*general status of the function block*)
		lastErrorID : UINT := 0; (*last error ID (check help for more information)*)
	END_STRUCT;
	brdkSafety_data_internal_typ : 	STRUCT  (*download data internal*)
		temp : USINT := 0; (*temp value*)
		k : USINT := 0; (*index*)
		j : USINT := 0; (*index*)
		i : USINT := 0; (*index*)
		state : brdkSafety_states_typ := (0); (*function block state*)
		acknowledgeMachineOptions : DownloadAcknMaOpTypeV1; (*acknowledge machine options. AcknBitOptions[0].0 equals "ExternalMachineOption000" and AcknBitOptions[0].1 equals "ExternalMachineOption001"*)
		acknowledgeExtMachineOptions : DownloadAcknExtMaOpTypeV1; (*acknowledge machine options*)
		configurationCmdExtMaOpType : ConfigurationCmdExtMaOpTypeV2; (*command structure for extended machine options*)
		configurationCmdMaOpType : ConfigurationCmdMaOpTypeV2; (*command structure for machine options*)
		optionsBoolOut : ConfigurationBitOptionsTypeV1; (*machine options. BitData[0].0 equals "ExternalMachineOption000" and BitData[0].1 equals "ExternalMachineOption001"*)
		optionsIntOut : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationIntOptionsTypeV1; (*machine options INT*)
		optionsUintOut : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationUintOptionsTypeV1; (*machine options UINT*)
		optionsDintOut : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationDintOptionsTypeV1; (*machine options DINT*)
		optionsUdintOut : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationUdintOptionsTypeV1; (*machine options UDINT*)
		optionsBoolIn : ConfigurationBitOptionsTypeV1; (*machine options. BitData[0].0 equals "ExternalMachineOption000" and BitData[0].1 equals "ExternalMachineOption001"*)
		optionsIntIn : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationIntOptionsTypeV1; (*machine options INT*)
		optionsUintIn : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationUintOptionsTypeV1; (*machine options UINT*)
		optionsDintIn : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationDintOptionsTypeV1; (*machine options DINT*)
		optionsUdintIn : ARRAY[0..BRDKSAFETY_MAX_OPTIONS]OF ConfigurationUdintOptionsTypeV1; (*machine options UDINT*)
		moduleFlagsIn : ConfigurationModuleFlagsTypeV1; (*example: bit 1 in Optional[0] stands for SafeModule 1, bit 2 in Optional[0] for SafeModule 2, etc.*)
		downloadTableType : ARRAY[0..BRDKSAFETY_MAX_TABLES]OF DownloadTableTypeV1; (*data for the table objects*)
		downloadCmdMaOpType : DownloadCmdMaOpTypeV2; (*command structure for downloading machine options*)
		readData : safeConfigurationOnTarget_V2; (*function block safeConfigurationOnTarget*)
		downloadCmdExtMaOpType : DownloadCmdExtMaOpTypeV2; (*command structure for downloading extended machine options*)
		downloadCmdTableType : DownloadCmdTableTypeV2; (*command structure for downloading table objects*)
		downloadData : safeDownloadData; (*function block safeDownloadData*)
		moduleFlagsOut : ConfigurationModuleFlagsTypeV1; (*example: bit 1 in Optional[0] stands for SafeModule 1, bit 2 in Optional[0] for SafeModule 2, etc.*)
		EplSDORead_0 : EplSDORead; (*function block to read UDIDs from SL device*)
		AsIOAccRead_0 : AsIOAccRead; (*function block to read UDIDs from SLX device*)
		UDID_High : UINT := 0; (*UDID_high for SafelOGIC*)
		UDID_Low : UDINT := 0; (*UDID_low for SafeLOGIC*)
	END_STRUCT;
END_TYPE
